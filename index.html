<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ä¸´æ—¶ P2P èŠå¤©å®¤</title>
    <style>
        /* --- åŸºæœ¬æ ·å¼ --- */
        body { font-family: sans-serif; margin: 0; padding: 15px; background-color: #f4f7f6; display: flex; justify-content: center; color: #333; }
        #app-container { max-width: 700px; width: 100%; background: #fff; padding: 25px; border-radius: 10px; box-shadow: 0 5px 20px rgba(0, 0, 0, 0.08); display: flex; flex-direction: column; }
        h1 { text-align: center; color: #007bff; margin-top: 0; margin-bottom: 20px; }
        button { padding: 10px 20px; cursor: pointer; margin: 5px; font-size: 1em; border: none; border-radius: 5px; background-color: #007bff; color: white; transition: background-color 0.2s ease; }
        button:hover:not(:disabled) { background-color: #0056b3; }
        button:disabled { background-color: #a0cfff; cursor: not-allowed; }
        input[type="text"] { padding: 10px; border: 1px solid #ccc; border-radius: 5px; flex-grow: 1; margin-right: 10px; font-size: 1em; }
        p, label { margin-bottom: 10px; line-height: 1.5; }

        /* --- çŠ¶æ€ä¸è¿æ¥ --- */
        #status { margin-top: 15px; margin-bottom: 15px; font-weight: bold; text-align: center; min-height: 1.2em; padding: 10px; border-radius: 5px; background-color: #e9ecef; border: 1px solid #dee2e6; }
        .status-error { background-color: #f8d7da; color: #721c24; border-color: #f5c6cb; }
        .status-success { background-color: #d4edda; color: #155724; border-color: #c3e6cb; }
        #connection-info { padding: 15px; border: 1px dashed #ccc; background-color: #f8f9fa; border-radius: 5px; margin-bottom: 20px; text-align: center; }
        #share-url { width: 100%; padding: 8px; box-sizing: border-box; border: 1px solid #ccc; background: #eee; text-align: center; margin-top: 10px; font-family: monospace; cursor: pointer; }
        #copy-url-btn { margin-top: 5px; }

        /* --- èŠå¤©åŒºåŸŸ --- */
        #chat-area { margin-top: 20px; display: flex; flex-direction: column; flex-grow: 1; visibility: hidden; /* Hidden until connected */ }
        #chatbox { height: 350px; width: 100%; overflow-y: scroll; border: 1px solid #ccc; padding: 15px; background-color: #f4f7f6; margin-bottom: 15px; box-sizing: border-box; border-radius: 5px; scroll-behavior: smooth; }
        .message-wrapper { display: flex; margin-bottom: 10px; }
        .message { padding: 10px 15px; border-radius: 18px; max-width: 75%; word-wrap: break-word; box-shadow: 0 1px 1px rgba(0, 0, 0, 0.1); line-height: 1.4; }
        .message-sent { background-color: #dcf8c6; border-bottom-right-radius: 5px; margin-left: auto; }
        .message-received { background-color: #ffffff; border: 1px solid #eee; border-bottom-left-radius: 5px; margin-right: auto; }
        .message-sender { font-size: 0.8em; color: #6c757d; margin-bottom: 3px; display: block; font-weight: bold; }
        .message-system { font-style: italic; color: #6c757d; text-align: center; font-size: 0.9em; margin: 15px 0; width: 100%; }
        #input-area { display: flex; align-items: center; margin-top: auto; }
        #message-input { flex-grow: 1; }
        #select-file-btn { background: none; border: none; font-size: 1.6em; cursor: pointer; color: #007bff; padding: 5px 10px; }
        #select-file-btn:hover { color: #0056b3; }
        #file-input { display: none; }
        #file-status { margin-top: 8px; margin-bottom: 8px; font-size: 0.9em; color: #555; min-height: 1.2em; text-align: center; }
        .download-link { display: inline-block; margin: 5px 5px 5px 0; padding: 5px 10px; color: #007bff; text-decoration: none; border: 1px solid #007bff; border-radius: 4px; background-color: #e7f3ff; font-size: 0.9em; transition: background-color 0.2s ease; }
        .download-link:hover { background-color: #cfe2ff; text-decoration: underline; }
        .file-info-wrapper { /* Wrapper for download links in system messages */ text-align: center; margin: 5px 0; }
    </style>
    <!-- PeerJS Library -->
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
</head>
<body>
    <div id="app-container">
        <h1>ä¸´æ—¶ P2P èŠå¤©å®¤</h1>

        <!-- Connection Info & Sharing -->
        <div id="connection-info">
            <p>åˆ†äº«ä¸‹é¢çš„é“¾æ¥ç»™æœ‹å‹åŠ å…¥èŠå¤©å®¤ (éœ€åœ¨åŒä¸€ WiFi):</p>
            <input type="text" id="share-url" readonly value="æ­£åœ¨ç”Ÿæˆé“¾æ¥...">
            <button id="copy-url-btn" onclick="copyShareUrl()">å¤åˆ¶é“¾æ¥</button>
            <p id="my-peer-id-display" style="font-size: 0.9em; color: #666; margin-top: 10px;">æˆ‘çš„ Peer ID: (è¿æ¥ä¸­...)</p>
        </div>

        <!-- Status Display -->
        <div id="status">çŠ¶æ€ï¼šæ­£åœ¨åˆå§‹åŒ–...</div>

        <!-- Chat Area -->
        <div id="chat-area">
            <div id="chatbox">
                <!-- Messages will appear here -->
            </div>
            <p id="file-status"></p>
            <div id="input-area">
                <input type="text" id="message-input" placeholder="è¾“å…¥æ¶ˆæ¯..." disabled>
                <button id="send-btn" title="å‘é€æ¶ˆæ¯" disabled>å‘é€</button>
                <input type="file" id="file-input">
                <button id="select-file-btn" title="å‘é€æ–‡ä»¶" disabled>ğŸ“</button>
            </div>
        </div>
    </div>

    <script>
        // --- Configuration ---
        const ROOM_PREFIX = "localchat-"; // Prefix for PeerJS IDs in this app
        const CHUNK_SIZE = 16 * 1024; // 16 KB for file transfer

        // --- DOM Elements ---
        const shareUrlInput = document.getElementById('share-url');
        const copyUrlBtn = document.getElementById('copy-url-btn');
        const myPeerIdDisplay = document.getElementById('my-peer-id-display');
        const statusDiv = document.getElementById('status');
        const chatAreaDiv = document.getElementById('chat-area');
        const chatboxDiv = document.getElementById('chatbox');
        const messageInput = document.getElementById('message-input');
        const sendBtn = document.getElementById('send-btn');
        const fileInput = document.getElementById('file-input');
        const selectFileBtn = document.getElementById('select-file-btn');
        const fileStatusP = document.getElementById('file-status');

        // --- State ---
        let peer = null;
        let myPeerId = null;
        let roomID = null;
        let connections = {}; // { peerId: DataConnection }
        let fileReceiveStates = {}; // { fileId: { meta, chunks: [], receivedSize } }
        // Note: File sending state is managed more locally in the sendFile function

        // --- Initialization ---
        window.onload = initialize;

        function initialize() {
            // Check URL for existing room ID (hash)
            if (window.location.hash) {
                roomID = window.location.hash.substring(1); // Get ID from URL hash (e.g., #roomId)
            } else {
                roomID = generateRoomID();
                // Update URL without reloading page to make it shareable
                history.pushState(null, null, '#' + roomID);
            }

            shareUrlInput.value = window.location.href;
            updateStatus('çŠ¶æ€ï¼šæ­£åœ¨è¿æ¥åˆ°ä¿¡ä»¤æœåŠ¡å™¨...');

            // Initialize PeerJS. If no ID is provided, the server generates one.
            // We don't need a predictable ID here as connections are managed via room logic.
            peer = new Peer(undefined, {
                // Optional: Specify host/port if using your own PeerServer
                // host: 'localhost',
                // port: 9000,
                // path: '/myapp'
                // Using the public PeerServer by default.
                debug: 2 // Set debug level (0-3) for console logs from PeerJS
            });

            setupPeerEventHandlers();
            setupUIEventHandlers();
        }

        function setupPeerEventHandlers() {
            peer.on('open', (id) => {
                myPeerId = id; // PeerJS provides the ID assigned by the server
                console.log('[PeerJS] è¿æ¥åˆ°ä¿¡ä»¤æœåŠ¡å™¨æˆåŠŸï¼Œæˆ‘çš„ Peer ID:', myPeerId);
                myPeerIdDisplay.textContent = `æˆ‘çš„ Peer ID: ${myPeerId}`;
                updateStatus(`çŠ¶æ€ï¼šç­‰å¾…ä¼™ä¼´åŠ å…¥æˆ¿é—´ #${roomID}...`, 'success');
                chatAreaDiv.style.visibility = 'visible'; // Show chat area now

                // Now that we have our ID, try to connect to others already in the room
                // This needs a mechanism. Simplest: Use a known ID for the "first" person?
                // Let's use a simpler "everyone connects to everyone" approach for now.
                // We need a way to discover peers. PeerJS doesn't have room listing directly.
                // **Workaround/Simplification:** Let's assume for now peers find each other via shared links.
                // When a new peer connects TO US, we then connect back TO THEM.
                // A better approach would involve a signaling server extension or a central "introducer" peer.

                // For this simplified version, we rely on 'connection' event.
                 displaySystemMessage(`ä½ å·²åŠ å…¥æˆ¿é—´ #${roomID}ã€‚ä½ çš„IDæ˜¯ ${myPeerId.substring(0,6)}...`);
                 displaySystemMessage("åˆ†äº«é¡µé¢é“¾æ¥ç»™æœ‹å‹åŠ å…¥ã€‚");

                 // Attempt connection if URL indicates a specific peer to connect to (enhancement - not standard)
                 // const urlParams = new URLSearchParams(window.location.search);
                 // const connectTo = urlParams.get('connectTo');
                 // if (connectTo) {
                 //     connectToPeer(connectTo);
                 // }
            });

            peer.on('connection', (conn) => {
                 console.log(`[PeerJS] æ”¶åˆ°æ¥è‡ª ${conn.peer} çš„è¿æ¥è¯·æ±‚`);
                 displaySystemMessage(`ä¼™ä¼´ (${conn.peer.substring(0,6)}...) æ­£åœ¨è¿æ¥...`);
                 setupConnectionEventHandlers(conn);
                 // Automatically accept and store connection
                 connections[conn.peer] = conn;
                 updateChatInputState();
            });

            peer.on('disconnected', () => {
                updateStatus('çŠ¶æ€ï¼šä¸ä¿¡ä»¤æœåŠ¡å™¨æ–­å¼€è¿æ¥ï¼Œå°è¯•é‡è¿...', 'error');
                console.warn('[PeerJS] ä¸ä¿¡ä»¤æœåŠ¡å™¨æ–­å¼€è¿æ¥ã€‚PeerJS ä¼šå°è¯•è‡ªåŠ¨é‡è¿ã€‚');
                 // PeerJS attempts to reconnect automatically.
                 // You might want to disable input here until reconnected.
                 enableChatInput(false);
            });

            peer.on('close', () => {
                // This happens when peer.destroy() is called.
                updateStatus('çŠ¶æ€ï¼šè¿æ¥å·²å½»åº•å…³é—­ã€‚', 'info');
                console.log('[PeerJS] Peer è¿æ¥å·²é”€æ¯ã€‚');
                cleanup();
            });

            peer.on('error', (err) => {
                console.error('[PeerJS] å‘ç”Ÿé”™è¯¯:', err);
                let message = `é”™è¯¯: ${err.message}`;
                if (err.type === 'peer-unavailable') {
                    message = `é”™è¯¯ï¼šæ— æ³•è¿æ¥åˆ°ä¼™ä¼´ (${err.message.split(': ')[1] || ''})ï¼Œå¯¹æ–¹å¯èƒ½å·²ç¦»çº¿ã€‚`;
                     // Clean up potential dangling connection attempt
                     delete connections[err.message.split(': ')[1]];
                } else if (err.type === 'network') {
                     message = 'é”™è¯¯ï¼šç½‘ç»œè¿æ¥é—®é¢˜ï¼Œæ— æ³•è¿æ¥åˆ°ä¿¡ä»¤æœåŠ¡å™¨æˆ–ä¼™ä¼´ã€‚';
                } else if (err.type === 'server-error') {
                     message = 'é”™è¯¯ï¼šä¿¡ä»¤æœåŠ¡å™¨å‡ºé”™ã€‚';
                } else if (err.type === 'webrtc') {
                     message = 'é”™è¯¯ï¼šWebRTC åˆå§‹åŒ–æˆ–è¿æ¥å¤±è´¥ (è¯¦è§æ§åˆ¶å°)ã€‚';
                 }
                updateStatus(message, 'error');
                // Consider cleanup based on error type
                 if (err.type !== 'peer-unavailable') {
                     // Maybe destroy peer on critical errors?
                     // peer.destroy();
                 }
                 updateChatInputState();
            });
        }

        function setupConnectionEventHandlers(conn) {
             conn.on('open', () => {
                 console.log(`[PeerJS] ä¸ ${conn.peer} çš„æ•°æ®è¿æ¥å·²å»ºç«‹`);
                 displaySystemMessage(`å·²è¿æ¥åˆ°ä¼™ä¼´ (${conn.peer.substring(0,6)}...)ï¼`);
                 // If this is the first connection, enable input
                 updateChatInputState();
                 // Optional: Send a hello message or request state
                 // conn.send(JSON.stringify({ type: 'hello', payload: { id: myPeerId } }));
             });

             conn.on('data', (data) => {
                 console.log(`[PeerJS] æ”¶åˆ°æ¥è‡ª ${conn.peer} çš„æ•°æ®`);
                 handleReceivedData(conn.peer, data);
             });

             conn.on('close', () => {
                 console.log(`[PeerJS] ä¸ ${conn.peer} çš„æ•°æ®è¿æ¥å·²å…³é—­`);
                 displaySystemMessage(`ä¼™ä¼´ (${conn.peer.substring(0,6)}...) å·²æ–­å¼€è¿æ¥ã€‚`);
                 delete connections[conn.peer];
                 delete fileReceiveStates[conn.peer]; // Clean up potential file transfer state
                 updateChatInputState();
             });

              conn.on('error', (err) => {
                 console.error(`[PeerJS] ä¸ ${conn.peer} çš„æ•°æ®è¿æ¥é”™è¯¯:`, err);
                 displaySystemMessage(`ä¸ä¼™ä¼´ (${conn.peer.substring(0,6)}...) çš„è¿æ¥å‡ºé”™ã€‚`);
                 delete connections[conn.peer];
                 updateChatInputState();
             });
        }

        function setupUIEventHandlers() {
             sendBtn.addEventListener('click', sendChatMessage);
             messageInput.addEventListener('keypress', (e) => {
                 if (e.key === 'Enter' && !e.shiftKey) {
                     e.preventDefault();
                     sendChatMessage();
                 }
             });
             selectFileBtn.addEventListener('click', () => fileInput.click());
             fileInput.addEventListener('change', handleFileSelect);
        }

        function connectToPeer(peerId) {
             if (!peer || peer.destroyed) {
                 updateStatus('é”™è¯¯ï¼šPeerJS æœªåˆå§‹åŒ–æˆ–å·²é”€æ¯', 'error');
                 return;
             }
             if (!peerId || peerId === myPeerId) {
                 console.warn('[PeerJS] å°è¯•è¿æ¥è‡ªèº«æˆ–æ— æ•ˆ ID:', peerId);
                 return;
             }
             if (connections[peerId]) {
                 console.log(`[PeerJS] å·²å­˜åœ¨ä¸ ${peerId} çš„è¿æ¥ï¼Œè·³è¿‡ã€‚`);
                 return;
             }

             console.log(`[PeerJS] å°è¯•è¿æ¥åˆ° Peer: ${peerId}`);
             displaySystemMessage(`æ­£åœ¨å°è¯•è¿æ¥ä¼™ä¼´ (${peerId.substring(0,6)}...)...`);

             try {
                const conn = peer.connect(peerId, {
                    reliable: true // Ensure reliable data transfer for chat/files
                });
                setupConnectionEventHandlers(conn); // Setup handlers immediately
                connections[conn.peer] = conn; // Store connection optimistically
             } catch (error) {
                console.error(`[PeerJS] è°ƒç”¨ peer.connect æ—¶å‡ºé”™: `, error);
                updateStatus(`é”™è¯¯: æ— æ³•å‘èµ·ä¸ ${peerId} çš„è¿æ¥`, 'error');
             }
        }

        function updateChatInputState() {
            const hasConnections = Object.keys(connections).length > 0;
            enableChatInput(hasConnections);
        }

        // --- UI Helpers ---
        function generateRoomID(length = 6) {
             const chars = 'abcdefghijklmnopqrstuvwxyz0123456789';
             let result = '';
             for (let i = 0; i < length; i++) {
                 result += chars.charAt(Math.floor(Math.random() * chars.length));
             }
             return result;
        }

        function copyShareUrl() {
            shareUrlInput.select();
            try {
                document.execCommand('copy');
                updateStatus('çŠ¶æ€ï¼šé“¾æ¥å·²å¤åˆ¶åˆ°å‰ªè´´æ¿ï¼', 'success');
                copyUrlBtn.textContent = 'å·²å¤åˆ¶!';
                setTimeout(() => { copyUrlBtn.textContent = 'å¤åˆ¶é“¾æ¥'; }, 1500);
            } catch (err) {
                console.error('å¤åˆ¶å¤±è´¥:', err);
                updateStatus('çŠ¶æ€ï¼šå¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨å¤åˆ¶é“¾æ¥ã€‚', 'error');
            }
        }

        function updateStatus(message, type = 'info') {
             statusDiv.textContent = message;
             statusDiv.className = ''; // Reset classes
             if (type === 'error') statusDiv.classList.add('status-error');
             else if (type === 'success') statusDiv.classList.add('status-success');
             console.log(`[UI Status ${type.toUpperCase()}] ${message}`);
        }

         function enableChatInput(enabled) {
             messageInput.disabled = !enabled;
             sendBtn.disabled = !enabled;
             selectFileBtn.disabled = !enabled;
         }

        function displaySystemMessage(message) {
             const msgDiv = document.createElement('div');
             msgDiv.classList.add('message-system');
             msgDiv.textContent = message;
             chatboxDiv.appendChild(msgDiv);
             scrollToBottom();
         }

        function displayChatMessage(senderId, message, isSent) {
             const wrapperDiv = document.createElement('div');
             wrapperDiv.classList.add('message-wrapper');
             const msgDiv = document.createElement('div');
             msgDiv.classList.add('message', isSent ? 'message-sent' : 'message-received');
             const senderSpan = document.createElement('span');
             senderSpan.classList.add('message-sender');
             senderSpan.textContent = isSent ? 'æˆ‘' : `ä¼™ä¼´ (${senderId.substring(0, 6)}...)`;
             const textNode = document.createTextNode(message);
             msgDiv.appendChild(senderSpan);
             msgDiv.appendChild(textNode);
             wrapperDiv.appendChild(msgDiv);
             chatboxDiv.appendChild(wrapperDiv);
             scrollToBottom();
         }

         function scrollToBottom() {
             chatboxDiv.scrollTop = chatboxDiv.scrollHeight;
         }

        // --- Data Sending ---
        function broadcast(data) {
            let sentToSomeone = false;
            Object.values(connections).forEach(conn => {
                if (conn && conn.open) { // Check if connection is open
                    try {
                        conn.send(data);
                        sentToSomeone = true;
                    } catch (e) {
                        console.error(`[Data Send] å‘é€æ•°æ®ç»™ ${conn.peer} å¤±è´¥:`, e);
                        displaySystemMessage(`å‘ä¼™ä¼´ (${conn.peer.substring(0,6)}...) å‘é€æ•°æ®å¤±è´¥ã€‚`);
                        // Maybe remove this connection?
                        // delete connections[conn.peer];
                        // updateChatInputState();
                    }
                }
            });
             if (!sentToSomeone && Object.keys(connections).length > 0) {
                 console.warn("[Data Send] æœ‰è¿æ¥å¯¹è±¡ï¼Œä½†æ²¡æœ‰ä¸€ä¸ªå¤„äº open çŠ¶æ€ã€‚");
             }
            return sentToSomeone;
        }

        function sendChatMessage() {
            const message = messageInput.value.trim();
            if (!message) return;
            const messageData = { type: 'chat', payload: { text: message } };
            if (broadcast(JSON.stringify(messageData))) {
                displayChatMessage(myPeerId, message, true);
                messageInput.value = '';
            } else {
                displaySystemMessage("æ— æ³•å‘é€æ¶ˆæ¯ï¼Œå½“å‰æ²¡æœ‰è¿æ¥åˆ°ä»»ä½•ä¼™ä¼´ã€‚");
            }
        }

        function handleFileSelect(event) {
            const files = event.target.files;
            if (!files || files.length === 0) return;
            if (Object.keys(connections).length === 0) {
                displaySystemMessage("æ— æ³•å‘é€æ–‡ä»¶ï¼Œæœªè¿æ¥åˆ°ä»»ä½•ä¼™ä¼´ã€‚");
                return;
            }
            const file = files[0];
            sendFile(file);
            fileInput.value = null; // Reset file input
        }

        function sendFile(file) {
            const fileId = `${myPeerId}-${Date.now()}-${file.name}`;
            displaySystemMessage(`å¼€å§‹å‘é€æ–‡ä»¶: ${file.name} (${formatBytes(file.size)})`);
            fileStatusP.textContent = `å¼€å§‹å‘é€ ${file.name}...`;

            const metadata = {
                type: 'file-meta',
                payload: { fileId, name: file.name, size: file.size, type: file.type || 'application/octet-stream', senderId: myPeerId }
            };
            broadcast(JSON.stringify(metadata));

            let offset = 0;
            const reader = new FileReader();

            reader.onload = (e) => {
                const chunk = e.target.result; // ArrayBuffer
                // We need to send the chunk *along with* the fileId.
                // SimplePeer allowed sending raw ArrayBuffer after metadata, but PeerJS data connection expects serializable data.
                // Best practice: Send an object containing the chunk data (e.g., base64 encoded, or use specific libraries if available)
                // Simplest (less efficient for large files): Base64 encode
                // **Correction:** PeerJS `DataConnection.send()` *can* handle ArrayBuffer directly! Let's use that.

                const chunkData = { type: 'file-chunk', payload: { fileId: fileId, data: chunk } };
                // Re-stringify approach for chunk metadata + data? No, send raw buffer.
                // OK, let's try sending the raw ArrayBuffer chunk *after* the metadata. Receiver needs to handle this state.
                // This relies on ordered delivery which 'reliable: true' should provide.

                const success = broadcast(chunk); // Send the raw ArrayBuffer

                if (!success) {
                    fileStatusP.textContent = `æ–‡ä»¶ ${file.name} å‘é€ä¸­æ–­ï¼ˆæ— è¿æ¥ä¼™ä¼´ï¼‰ã€‚`;
                    displaySystemMessage(`æ–‡ä»¶ ${file.name} å‘é€ä¸­æ­¢ã€‚`);
                    return; // Stop sending
                }

                offset += chunk.byteLength;
                const progress = Math.round((offset / file.size) * 100);
                fileStatusP.textContent = `æ­£åœ¨å‘é€ ${file.name}: ${progress}% (${formatBytes(offset)} / ${formatBytes(file.size)})`;

                if (offset < file.size) {
                    readNextChunk(reader, file, offset);
                } else {
                    const endMarker = { type: 'file-end', payload: { fileId: fileId, name: file.name, senderId: myPeerId } };
                    broadcast(JSON.stringify(endMarker));
                    fileStatusP.textContent = `æ–‡ä»¶ ${file.name} å‘é€å®Œæˆï¼`;
                    displaySystemMessage(`æ–‡ä»¶ ${file.name} å·²æˆåŠŸå‘é€ã€‚`);
                }
            };

            reader.onerror = (error) => {
                console.error(`[File Send ${fileId}] FileReader error:`, error);
                fileStatusP.textContent = `è¯»å–æ–‡ä»¶ ${file.name} æ—¶å‡ºé”™ã€‚`;
                displaySystemMessage(`å‘é€æ–‡ä»¶ ${file.name} æ—¶å‡ºé”™ã€‚`);
                // Send abort message?
                const abortMsg = { type: 'file-abort', payload: { fileId: fileId, reason: 'FileReader error' } };
                broadcast(JSON.stringify(abortMsg));
            };

            readNextChunk(reader, file, offset); // Start reading the first chunk
        }

        function readNextChunk(reader, file, offset) {
            const slice = file.slice(offset, offset + CHUNK_SIZE);
            reader.readAsArrayBuffer(slice);
        }

        // --- Data Receiving ---
        function handleReceivedData(peerId, data) {
             // Data can be string (JSON) or ArrayBuffer (file chunk)
             if (typeof data === 'string') {
                 try {
                     const message = JSON.parse(data);
                     console.log(`[Data Received JSON from ${peerId}]`, message);
                     const senderId = message.payload?.senderId || peerId; // Use senderId from payload if available

                     switch (message.type) {
                         case 'chat':
                             displayChatMessage(senderId, message.payload.text, false);
                             break;
                         case 'file-meta':
                             handleFileMeta(senderId, message.payload);
                             break;
                         case 'file-end':
                             handleFileEnd(senderId, message.payload);
                             break;
                         case 'file-abort':
                             handleFileAbort(senderId, message.payload);
                             break;
                         default:
                             console.warn(`[Data] æ”¶åˆ°æ¥è‡ª ${peerId} çš„æœªçŸ¥ç±»å‹ JSON æ•°æ®:`, message);
                     }
                 } catch (e) {
                     console.error(`[Data] è§£ææ¥è‡ª ${peerId} çš„ JSON æ•°æ®æ—¶å‡ºé”™:`, e, data);
                 }
             } else if (data instanceof ArrayBuffer) {
                 console.log(`[Data Received Buffer from ${peerId}] Size: ${data.byteLength}`);
                 // Assume it's a file chunk based on state
                 handleFileChunk(peerId, data);
             } else {
                 console.warn(`[Data] æ”¶åˆ°æ¥è‡ª ${peerId} çš„æœªçŸ¥æ ¼å¼æ•°æ®:`, data);
             }
        }

        function handleFileMeta(senderId, meta) {
            const { fileId, name, size, type } = meta;
            if (!fileId || !name || size === undefined) return;
            fileReceiveStates[fileId] = { meta, chunks: [], receivedSize: 0 };
            displaySystemMessage(`(${senderId.substring(0,6)}...) å¼€å§‹å‘é€æ–‡ä»¶: ${name} (${formatBytes(size)})`);
            fileStatusP.textContent = `å‡†å¤‡æ¥æ”¶æ¥è‡ª (${senderId.substring(0,6)}...) çš„ ${name}...`;
        }

        function handleFileChunk(peerId, chunk) {
            // Find the active file transfer for this chunk. Needs fileId association.
            // **Crucial Assumption:** Chunks arrive *after* metadata for the same fileId.
            // Find the fileId this peer is currently sending us. Fragile if multiple concurrent allowed.
            let targetFileId = null;
            for (const id in fileReceiveStates) {
                // Match based on sender and assume latest metadata is the active one
                if (fileReceiveStates[id].meta.senderId === peerId) {
                    targetFileId = id;
                    break; // Assume only one file transfer active from this peer
                }
            }

            if (!targetFileId || !fileReceiveStates[targetFileId]) {
                console.warn(`[File Receive] æ”¶åˆ°æ¥è‡ª ${peerId} çš„æ–‡ä»¶å—ï¼Œä½†æ‰¾ä¸åˆ°è¿›è¡Œä¸­çš„ä¼ è¾“çŠ¶æ€ã€‚`);
                return;
            }

            const state = fileReceiveStates[targetFileId];
            state.chunks.push(chunk);
            state.receivedSize += chunk.byteLength;
            const progress = Math.round((state.receivedSize / state.meta.size) * 100);
            fileStatusP.textContent = `æ­£åœ¨æ¥æ”¶æ¥è‡ª (${state.meta.senderId.substring(0,6)}...) çš„ ${state.meta.name}: ${progress}%`;
        }

        function handleFileEnd(senderId, payload) {
            const { fileId, name } = payload;
            if (!fileId || !fileReceiveStates[fileId]) return;

            const state = fileReceiveStates[fileId];
             // Optional: Verify name match state.meta.name === name

            if (state.receivedSize !== state.meta.size) {
                console.warn(`[File Receive ${fileId}] æ–‡ä»¶å¤§å°ä¸åŒ¹é…! é¢„æœŸ: ${state.meta.size}, æ”¶åˆ°: ${state.receivedSize}`);
                displaySystemMessage(`æ–‡ä»¶ ${state.meta.name} æ¥æ”¶ä¸å®Œæ•´ã€‚`);
                fileStatusP.textContent = `æ–‡ä»¶ ${state.meta.name} æ¥æ”¶ä¸å®Œæ•´ã€‚`;
            } else {
                const receivedBlob = new Blob(state.chunks, { type: state.meta.type });
                displaySystemMessage(`æ–‡ä»¶ ${state.meta.name} (${formatBytes(state.receivedSize)}) æ¥æ”¶å®Œæˆã€‚`);
                fileStatusP.textContent = `æ–‡ä»¶ ${state.meta.name} æ¥æ”¶å®Œæˆã€‚`;
                createDownloadLink(receivedBlob, state.meta.name, senderId);
            }
            delete fileReceiveStates[fileId]; // Clean up state
        }

         function handleFileAbort(senderId, payload) {
             const { fileId, reason } = payload;
             if (fileReceiveStates[fileId]) {
                 displaySystemMessage(`æ¥è‡ª (${senderId.substring(0,6)}...) çš„æ–‡ä»¶ ${fileReceiveStates[fileId].meta.name} ä¼ è¾“ä¸­æ­¢: ${reason}`);
                 fileStatusP.textContent = `æ–‡ä»¶ ${fileReceiveStates[fileId].meta.name} æ¥æ”¶ä¸­æ­¢ã€‚`;
                 delete fileReceiveStates[fileId];
             }
         }

        function createDownloadLink(blob, filename, senderId) {
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.classList.add('download-link');
            link.href = url;
            link.download = filename;
            link.textContent = `ä¸‹è½½ ${filename}`; // (æ¥è‡ª ${senderId.substring(0,6)}...)

            // Append link in a system message for clarity
            const wrapper = document.createElement('div');
            wrapper.classList.add('file-info-wrapper');
            wrapper.appendChild(link);
            chatboxDiv.appendChild(wrapper); // Add download link inside chatbox
            scrollToBottom();

            link.onclick = () => { setTimeout(() => URL.revokeObjectURL(url), 1500); };
        }

        // --- Utility Functions ---
        function formatBytes(bytes, decimals = 2) { /* ... same as before ... */
             if (!+bytes) return '0 Bytes';
             const k = 1024;
             const dm = decimals < 0 ? 0 : decimals;
             const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
             const i = Math.floor(Math.log(bytes) / Math.log(k));
             return `${parseFloat((bytes / Math.pow(k, i)).toFixed(dm))} ${sizes[i]}`;
        }

        function cleanup() {
            // Close all data connections
            Object.values(connections).forEach(conn => {
                if (conn && conn.close) {
                    conn.close();
                }
            });
            connections = {};
            fileReceiveStates = {};
             // Destroy the PeerJS object
             if (peer && !peer.destroyed) {
                 peer.destroy();
             }
             peer = null;
             myPeerId = null;
             enableChatInput(false);
             console.log("[Cleanup] Peer and connections cleaned up.");
        }

        // Close connections when the page is unloaded
        window.addEventListener('beforeunload', cleanup);

    </script>
</body>
</html>